s11.3	"the canonicalisation method highlighting difficult cases"
s11.3	"the canonicalisation method highlighting difficult cases"	rdf:subject	"canonicalisation method"
s11.3	"canonicalisation method"	rdfs:subClassOf	"method"
s11.3	"canonicalisation method"	rdfs:member	"canonicalisation"
s11.3	"the canonicalisation method highlighting difficult cases"	rdf:predicate	"highlight"
s11.3	"the canonicalisation method highlighting difficult cases"	rdf:object	"difficult cases"
s11.3	"difficult cases"	rdfs:member	"difficult"
s11.3	"difficult cases"	rdfs:subClassOf	"cases"
s11.2	"synthetic queries stresstest the canonicalisation method highlighting difficult cases"
s11.2	"synthetic queries stresstest the canonicalisation method highlighting difficult cases"	rdf:subject	"synthetic queries"
s11.2	"synthetic queries"	rdfs:member	"synthetic"
s11.2	"synthetic queries"	rdfs:subClassOf	"queries"
s11.2	"synthetic queries stresstest the canonicalisation method highlighting difficult cases"	rdf:predicate	"stresstest"
s11.2	"synthetic queries stresstest the canonicalisation method highlighting difficult cases"	rdf:object	"canonicalisation method highlighting difficult cases"
s11.2	"canonicalisation method highlighting difficult cases"	rdfs:member	"difficult cases"
s11.2	"canonicalisation method highlighting difficult cases"	rdfs:member	"canonicalisation method"
s11.2	"canonicalisation method"	rdfs:subClassOf	"method"
s11.2	"difficult cases"	rdfs:member	"difficult"
s11.2	"difficult cases"	rdfs:subClassOf	"cases"
s11.2	"canonicalisation method"	rdfs:member	"canonicalisation"
s11.2	"canonicalisation method highlighting"	rdfs:member	"canonicalisation method"
s11.2	"canonicalisation method highlighting"	rdfs:member	"highlighting"
s11.1	"synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"
s11.1	"synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:subject	"synthetic queries"
s11.1	"synthetic queries"	rdfs:member	"synthetic"
s11.1	"synthetic queries"	rdfs:subClassOf	"queries"
s11.1	"synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:predicate	"design"
s11.1	"synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:object	"stresstest the canonicalisation method highlighting difficult cases"
s11.1	"stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"difficult cases"
s11.1	"stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"canonicalisation method"
s11.1	"canonicalisation method"	rdfs:subClassOf	"method"
s11.1	"difficult cases"	rdfs:member	"difficult"
s11.1	"difficult cases"	rdfs:subClassOf	"cases"
s11.1	"canonicalisation method"	rdfs:member	"canonicalisation"
s11.1	"canonicalisation method highlighting"	rdfs:member	"canonicalisation method"
s11.1	"canonicalisation method highlighting"	rdfs:member	"highlighting"
s11	"we also present the results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"
s11	"we also present the results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:subject	"We"
s11	"we also present the results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:predicate	"present"
s11	"we also present the results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdf:object	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"
s11	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"difficult cases"
s11	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"canonicalisation method"
s11	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"results"
s11	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"synthetic queries"
s11	"results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	rdfs:member	"experiments"
s11	"canonicalisation method"	rdfs:member	"canonicalisation"
s11	"canonicalisation method"	rdfs:subClassOf	"method"
s11	"difficult cases"	rdfs:member	"difficult"
s11	"synthetic queries"	rdfs:subClassOf	"queries"
s11	"synthetic queries"	rdfs:member	"synthetic"
s11	"difficult cases"	rdfs:subClassOf	"cases"
s11	"results of experiments"	rdfs:member	"results"
s11	"results of experiments"	rdfs:member	"experiments"
s11	"experiments over synthetic queries"	rdfs:member	"experiments"
s11	"experiments over synthetic queries"	rdfs:member	"synthetic queries"
s11	"synthetic queries designed"	rdfs:member	"synthetic queries"
s11	"synthetic queries designed"	rdfs:member	"designed"
s11	"canonicalisation method highlighting"	rdfs:member	"canonicalisation method"
s11	"canonicalisation method highlighting"	rdfs:member	"highlighting"
s11	"we also present the results of experiments over synthetic queries designed to stresstest the canonicalisation method highlighting difficult cases"	local:AM-DIS	"also"
s10	"an algorithm that performs syntactic canonicalisation of sparql queries"
s10	"an algorithm that performs syntactic canonicalisation of sparql queries"	rdf:subject	"algorithm"
s10	"an algorithm that performs syntactic canonicalisation of sparql queries"	rdf:predicate	"perform"
s10	"an algorithm that performs syntactic canonicalisation of sparql queries"	rdf:object	"syntactic canonicalisation of SPARQL queries"
s10	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s10	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s10	"sparql queries"	rdfs:subClassOf	"queries"
s10	"syntactic canonicalisation"	rdfs:member	"syntactic"
s10	"sparql queries"	rdfs:member	"sparql"
s10	"syntactic canonicalisation"	rdfs:subClassOf	"canonicalisation"
s10	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s10	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s9.1	"an algorithm detects more equivalent queries than when compared with purely syntactic methods"
s9.1	"an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:subject	"algorithm"
s9.1	"an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:predicate	"detect"
s9.1	"an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:object	"equivalent queries than when compared with purely syntactic methods"
s9.1	"equivalent queries than when compared with purely syntactic methods"	rdfs:member	"equivalent queries"
s9.1	"equivalent queries than when compared with purely syntactic methods"	rdfs:member	"purely syntactic methods"
s9.1	"syntactic methods"	rdfs:subClassOf	"methods"
s9.1	"purely syntactic"	rdfs:member	"purely"
s9.1	"equivalent queries"	rdfs:subClassOf	"queries"
s9.1	"purely syntactic methods"	rdfs:subClassOf	"methods"
s9.1	"equivalent queries"	rdfs:member	"equivalent"
s9.1	"purely syntactic methods"	rdfs:member	"purely syntactic"
s9.1	"purely syntactic"	rdfs:subClassOf	"syntactic"
s9.1	"syntactic methods"	rdfs:member	"syntactic"
s9.1	"when compared"	rdfs:subClassOf	"compared"
s9.1	"when compared with syntactic methods"	rdfs:member	"when compared"
s9.1	"when compared with syntactic methods"	rdfs:member	"syntactic methods"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem we show that an algorithm detects more equivalent queries than when compared with purely syntactic methods"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem we show that an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:subject	"we"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem we show that an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:predicate	"show"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem we show that an algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdf:object	"algorithm detects more equivalent queries than when compared with purely syntactic methods"
s9	"algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdfs:member	"purely syntactic methods"
s9	"algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdfs:member	"algorithm detects"
s9	"algorithm detects more equivalent queries than when compared with purely syntactic methods"	rdfs:member	"more equivalent queries"
s9	"more equivalent"	rdfs:subClassOf	"equivalent"
s9	"algorithm detects"	rdfs:subClassOf	"detects"
s9	"syntactic methods"	rdfs:subClassOf	"methods"
s9	"more equivalent queries"	rdfs:subClassOf	"queries"
s9	"purely syntactic"	rdfs:member	"purely"
s9	"algorithm detects"	rdfs:member	"algorithm"
s9	"purely syntactic methods"	rdfs:subClassOf	"methods"
s9	"equivalent queries"	rdfs:subClassOf	"queries"
s9	"equivalent queries"	rdfs:member	"equivalent"
s9	"purely syntactic methods"	rdfs:member	"purely syntactic"
s9	"purely syntactic"	rdfs:subClassOf	"syntactic"
s9	"more equivalent"	rdfs:member	"more"
s9	"more equivalent queries"	rdfs:member	"more equivalent"
s9	"syntactic methods"	rdfs:member	"syntactic"
s9	"when compared"	rdfs:subClassOf	"compared"
s9	"when compared with syntactic methods"	rdfs:member	"when compared"
s9	"when compared with syntactic methods"	rdfs:member	"syntactic methods"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem we show that an algorithm detects more equivalent queries than when compared with purely syntactic methods"	local:AM-ADV	"Despite the fact that canonicalisation must be harder than the equivalence problem"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"canonicalisation"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"fact"
s9	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"equivalence problem"
s9	"equivalence problem"	rdfs:subClassOf	"problem"
s9	"equivalence problem"	rdfs:member	"equivalence"
s9	"must harder"	rdfs:subClassOf	"harder"
s9	"must harder than equivalence problem"	rdfs:member	"must harder"
s9	"must harder than equivalence problem"	rdfs:member	"equivalence problem"
s8.1	"the answers for the canonicalised query will not change"
s8.1	"the answers for the canonicalised query will not change"	rdf:subject	"answers for the canonicalised query"
s8.1	"answers for the canonicalised query"	rdfs:member	"answers"
s8.1	"answers for the canonicalised query"	rdfs:member	"canonicalised query"
s8.1	"canonicalised query"	rdfs:subClassOf	"query"
s8.1	"canonicalised query"	rdfs:member	"canonicalised"
s8.1	"answers for canonicalised query"	rdfs:member	"answers"
s8.1	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s8.1	"the answers for the canonicalised query will not change"	rdf:predicate	"not change"
s8.1	"the answers for the canonicalised query will not change"	local:AM-MOD	"will"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem we show an algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem we show an algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdf:subject	"we"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem we show an algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdf:predicate	"show"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem we show an algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdf:object	"algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"
s8	"algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdfs:member	"algorithm"
s8	"algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdfs:member	"realworld queries"
s8	"algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdfs:member	"answers"
s8	"algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	rdfs:member	"canonicalised query"
s8	"canonicalised query"	rdfs:subClassOf	"query"
s8	"realworld queries"	rdfs:subClassOf	"queries"
s8	"realworld queries"	rdfs:member	"realworld"
s8	"canonicalised query"	rdfs:member	"canonicalised"
s8	"not change"	rdfs:subClassOf	"change"
s8	"will not change"	rdfs:subClassOf	"not change"
s8	"answers for canonicalised query"	rdfs:member	"answers"
s8	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s8	"will not change versus original"	rdfs:member	"will not change"
s8	"will not change versus original"	rdfs:member	"original"
s8	"practical for realworld queries"	rdfs:member	"practical"
s8	"practical for realworld queries"	rdfs:member	"realworld queries"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem we show an algorithm such that the answers for the canonicalised query will not change versus the original to be practical for realworld queries"	local:AM-ADV	"Despite the fact that canonicalisation must be harder than the equivalence problem"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"canonicalisation"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"fact"
s8	"despite the fact that canonicalisation must be harder than the equivalence problem"	rdfs:member	"equivalence problem"
s8	"equivalence problem"	rdfs:subClassOf	"problem"
s8	"equivalence problem"	rdfs:member	"equivalence"
s8	"must harder"	rdfs:subClassOf	"harder"
s8	"must harder than equivalence problem"	rdfs:member	"must harder"
s8	"must harder than equivalence problem"	rdfs:member	"equivalence problem"
s7	"realworld queries taken from sparql endpoint logs"
s7	"realworld queries taken from sparql endpoint logs"	rdf:subject	"realworld queries"
s7	"realworld queries"	rdfs:subClassOf	"queries"
s7	"realworld queries"	rdfs:member	"realworld"
s7	"realworld queries taken from sparql endpoint logs"	rdf:predicate	"take"
s7	"realworld queries taken from sparql endpoint logs"	rdf:object	"SPARQL endpoint logs"
s7	"sparql endpoint"	rdfs:subClassOf	"endpoint"
s7	"endpoint logs"	rdfs:subClassOf	"logs"
s7	"sparql endpoint"	rdfs:member	"sparql"
s7	"endpoint logs"	rdfs:member	"endpoint"
s7	"sparql endpoint logs"	rdfs:member	"sparql endpoint"
s7	"sparql endpoint logs"	rdfs:subClassOf	"logs"
s7	"sparql endpoint logs"	rdfs:subClassOf	"endpoint logs"
s6.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"
s6.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	rdf:subject	"algorithm that performs syntactic canonicalisation of SPARQL queries such that the answers for the canonicalised query"
s6.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"sparql queries"
s6.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"canonicalised query"
s6.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"algorithm"
s6.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"syntactic canonicalisation"
s6.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"answers"
s6.2	"sparql queries"	rdfs:member	"sparql"
s6.2	"sparql queries"	rdfs:subClassOf	"queries"
s6.2	"canonicalised query"	rdfs:subClassOf	"query"
s6.2	"syntactic canonicalisation"	rdfs:member	"syntactic"
s6.2	"canonicalised query"	rdfs:member	"canonicalised"
s6.2	"syntactic canonicalisation"	rdfs:subClassOf	"canonicalisation"
s6.2	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s6.2	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s6.2	"answers for canonicalised query"	rdfs:member	"answers"
s6.2	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s6.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	rdf:predicate	"not change"
s6.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	local:AM-MOD	"will"
s6.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"
s6.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:subject	"SPARQL"
s6.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:predicate	"query"
s6.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:object	"answers for the canonicalised query will not change versus the original"
s6.1	"answers for the canonicalised query will not change versus the original"	rdfs:member	"answers"
s6.1	"answers for the canonicalised query will not change versus the original"	rdfs:member	"canonicalised query"
s6.1	"canonicalised query"	rdfs:subClassOf	"query"
s6.1	"canonicalised query"	rdfs:member	"canonicalised"
s6.1	"not change"	rdfs:subClassOf	"change"
s6.1	"will not change"	rdfs:subClassOf	"not change"
s6.1	"answers for canonicalised query"	rdfs:member	"answers"
s6.1	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s6.1	"will not change versus original"	rdfs:member	"will not change"
s6.1	"will not change versus original"	rdfs:member	"original"
s6	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"
s6	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:subject	"algorithm"
s6	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:predicate	"perform"
s6	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:object	"syntactic canonicalisation of SPARQL queries such that the answers for the canonicalised query will not change versus the original"
s6	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"answers"
s6	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"sparql queries"
s6	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"syntactic canonicalisation"
s6	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"canonicalised query"
s6	"sparql queries"	rdfs:member	"sparql"
s6	"sparql queries"	rdfs:subClassOf	"queries"
s6	"canonicalised query"	rdfs:subClassOf	"query"
s6	"canonicalised query"	rdfs:member	"canonicalised"
s6	"syntactic canonicalisation"	rdfs:member	"syntactic"
s6	"syntactic canonicalisation"	rdfs:subClassOf	"canonicalisation"
s6	"not change"	rdfs:subClassOf	"change"
s6	"will not change"	rdfs:subClassOf	"not change"
s6	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s6	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s6	"answers for canonicalised query"	rdfs:member	"answers"
s6	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s6	"will not change versus original"	rdfs:member	"will not change"
s6	"will not change versus original"	rdfs:member	"original"
s4	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if"
s4	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if"	rdf:subject	"We"
s4	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if"	rdf:predicate	"guarantee"
s4	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if"	rdf:object	"canonicalisation of two queries within a core fragment of SPARQL is equal if"
s4	"canonicalisation of two queries within a core fragment of sparql is equal if"	rdfs:member	"canonicalisation"
s4	"canonicalisation of two queries within a core fragment of sparql is equal if"	rdfs:member	"queries"
s4	"canonicalisation of two queries within a core fragment of sparql is equal if"	rdfs:member	"sparql"
s4	"canonicalisation of two queries within a core fragment of sparql is equal if"	rdfs:member	"core fragment"
s4	"core fragment"	rdfs:member	"core"
s4	"core fragment"	rdfs:subClassOf	"fragment"
s4	"two queries"	rdfs:subClassOf	"queries"
s4	"canonicalisation of two queries"	rdfs:member	"canonicalisation"
s4	"canonicalisation of two queries"	rdfs:member	"two queries"
s4	"two queries within core fragment"	rdfs:member	"two queries"
s4	"two queries within core fragment"	rdfs:member	"core fragment"
s4	"core fragment of sparql"	rdfs:member	"core fragment"
s4	"core fragment of sparql"	rdfs:member	"sparql"
s4	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if"	local:AM-MOD	"can"
s3.1	"we also support other sparql features"
s3.1	"we also support other sparql features"	rdf:subject	"We"
s3.1	"we also support other sparql features"	rdf:predicate	"support"
s3.1	"we also support other sparql features"	rdf:object	"SPARQL features"
s3.1	"sparql features"	rdfs:member	"sparql"
s3.1	"sparql features"	rdfs:subClassOf	"features"
s3.1	"we also support other sparql features"	local:AM-DIS	"also"
s3	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"
s3	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdf:subject	"We"
s3	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdf:predicate	"guarantee"
s3	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdf:object	"canonicalisation of two queries within a core fragment of SPARQL is equal if the two queries are equivalent We also support other SPARQL features but with a weaker soundness guarantee that the is equivalent to the input query"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"other sparql features"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"sparql"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"core fragment"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"queries"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"canonicalisation"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"input query"
s3	"canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	rdfs:member	"weaker soundness guarantee"
s3	"weaker soundness"	rdfs:subClassOf	"soundness"
s3	"other sparql"	rdfs:member	"other"
s3	"input query"	rdfs:member	"input"
s3	"input query"	rdfs:subClassOf	"query"
s3	"other sparql"	rdfs:subClassOf	"sparql"
s3	"weaker soundness guarantee"	rdfs:member	"weaker soundness"
s3	"soundness guarantee"	rdfs:subClassOf	"guarantee"
s3	"sparql features"	rdfs:member	"sparql"
s3	"sparql features"	rdfs:subClassOf	"features"
s3	"other sparql features"	rdfs:subClassOf	"features"
s3	"weaker soundness"	rdfs:member	"weaker"
s3	"core fragment"	rdfs:member	"core"
s3	"soundness guarantee"	rdfs:member	"soundness"
s3	"core fragment"	rdfs:subClassOf	"fragment"
s3	"other sparql features"	rdfs:member	"other sparql"
s3	"weaker soundness guarantee"	rdfs:subClassOf	"guarantee"
s3	"weaker soundness guarantee"	rdfs:subClassOf	"soundness guarantee"
s3	"other sparql features"	rdfs:subClassOf	"sparql features"
s3	"also support"	rdfs:subClassOf	"support"
s3	"two queries"	rdfs:subClassOf	"queries"
s3	"two queries"	rdfs:subClassOf	"queries"
s3	"canonicalisation of two queries"	rdfs:member	"canonicalisation"
s3	"canonicalisation of two queries"	rdfs:member	"two queries"
s3	"two queries within core fragment"	rdfs:member	"two queries"
s3	"two queries within core fragment"	rdfs:member	"core fragment"
s3	"core fragment of sparql"	rdfs:member	"core fragment"
s3	"core fragment of sparql"	rdfs:member	"sparql"
s3	"equivalent to input query"	rdfs:member	"equivalent"
s3	"equivalent to input query"	rdfs:member	"input query"
s3	"we can guarantee that the canonicalisation of two queries within a core fragment of sparql is equal if the two queries are equivalent we also support other sparql features but with a weaker soundness guarantee that the is equivalent to the input query"	local:AM-MOD	"can"
s2	"despite this complexity in this paper we propose an algorithm"
s2	"despite this complexity in this paper we propose an algorithm"	rdf:subject	"we"
s2	"despite this complexity in this paper we propose an algorithm"	rdf:predicate	"propose"
s2	"despite this complexity in this paper we propose an algorithm"	rdf:object	"algorithm"
s2	"despite this complexity in this paper we propose an algorithm"	local:AM-ADV	"Despite this complexity in this paper"
s2	"despite this complexity in this paper"	rdfs:member	"paper"
s2	"despite this complexity in this paper"	rdfs:member	"complexity"
s2	"complexity in paper"	rdfs:member	"complexity"
s2	"complexity in paper"	rdfs:member	"paper"
s1.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"
s1.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	rdf:subject	"algorithm that performs syntactic canonicalisation of SPARQL queries such that the answers for the canonicalised query"
s1.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"sparql queries"
s1.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"canonicalised query"
s1.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"algorithm"
s1.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"syntactic canonicalisation"
s1.2	"algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query"	rdfs:member	"answers"
s1.2	"sparql queries"	rdfs:member	"sparql"
s1.2	"sparql queries"	rdfs:subClassOf	"queries"
s1.2	"canonicalised query"	rdfs:subClassOf	"query"
s1.2	"syntactic canonicalisation"	rdfs:member	"syntactic"
s1.2	"canonicalised query"	rdfs:member	"canonicalised"
s1.2	"syntactic canonicalisation"	rdfs:subClassOf	"canonicalisation"
s1.2	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s1.2	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s1.2	"answers for canonicalised query"	rdfs:member	"answers"
s1.2	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s1.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	rdf:predicate	"not change"
s1.2	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change"	local:AM-MOD	"will"
s1.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"
s1.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:subject	"SPARQL"
s1.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:predicate	"query"
s1.1	"an algorithm that performs syntactic canonicalisation sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:object	"answers for the canonicalised query will not change versus the original"
s1.1	"answers for the canonicalised query will not change versus the original"	rdfs:member	"answers"
s1.1	"answers for the canonicalised query will not change versus the original"	rdfs:member	"canonicalised query"
s1.1	"canonicalised query"	rdfs:subClassOf	"query"
s1.1	"canonicalised query"	rdfs:member	"canonicalised"
s1.1	"not change"	rdfs:subClassOf	"change"
s1.1	"will not change"	rdfs:subClassOf	"not change"
s1.1	"answers for canonicalised query"	rdfs:member	"answers"
s1.1	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s1.1	"will not change versus original"	rdfs:member	"will not change"
s1.1	"will not change versus original"	rdfs:member	"original"
s1	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"
s1	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:subject	"algorithm"
s1	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:predicate	"perform"
s1	"an algorithm that performs syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdf:object	"syntactic canonicalisation of SPARQL queries such that the answers for the canonicalised query will not change versus the original"
s1	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"answers"
s1	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"sparql queries"
s1	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"syntactic canonicalisation"
s1	"syntactic canonicalisation of sparql queries such that the answers for the canonicalised query will not change versus the original"	rdfs:member	"canonicalised query"
s1	"sparql queries"	rdfs:member	"sparql"
s1	"sparql queries"	rdfs:subClassOf	"queries"
s1	"canonicalised query"	rdfs:subClassOf	"query"
s1	"canonicalised query"	rdfs:member	"canonicalised"
s1	"syntactic canonicalisation"	rdfs:member	"syntactic"
s1	"syntactic canonicalisation"	rdfs:subClassOf	"canonicalisation"
s1	"not change"	rdfs:subClassOf	"change"
s1	"will not change"	rdfs:subClassOf	"not change"
s1	"syntactic canonicalisation of sparql queries"	rdfs:member	"syntactic canonicalisation"
s1	"syntactic canonicalisation of sparql queries"	rdfs:member	"sparql queries"
s1	"answers for canonicalised query"	rdfs:member	"answers"
s1	"answers for canonicalised query"	rdfs:member	"canonicalised query"
s1	"will not change versus original"	rdfs:member	"will not change"
s1	"will not change versus original"	rdfs:member	"original"
s0.4	"further query features makes the problem"
s0.4	"further query features makes the problem"	rdf:subject	"query features"
s0.4	"query features"	rdfs:subClassOf	"features"
s0.4	"query features"	rdfs:member	"query"
s0.4	"further query features makes the problem"	rdf:predicate	"make"
s0.4	"further query features makes the problem"	rdf:object	"problem"
s0.3	"npcomplete where adding further query features"
s0.3	"npcomplete where adding further query features"	rdf:subject	"NPcomplete"
s0.3	"npcomplete where adding further query features"	rdf:predicate	"add"
s0.3	"npcomplete where adding further query features"	rdf:object	"query features"
s0.3	"query features"	rdfs:subClassOf	"features"
s0.3	"query features"	rdfs:member	"query"
s0.2	"deciding"
s0.2	"deciding"	rdf:predicate	"decide"
s0.1	"sparql detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"
s0.1	"sparql detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:subject	"SPARQL"
s0.1	"sparql detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:predicate	"detect"
s0.1	"sparql detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:object	"equivalent queries deciding if two conjunctive queries are equivalent is NPcomplete where adding further query features makes the problem undecidable"
s0.1	"equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"problem"
s0.1	"equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"further query features"
s0.1	"equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"npcomplete"
s0.1	"equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"conjunctive queries"
s0.1	"equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"equivalent queries"
s0.1	"query features"	rdfs:subClassOf	"features"
s0.1	"further query"	rdfs:member	"further"
s0.1	"further query features"	rdfs:member	"further query"
s0.1	"equivalent queries"	rdfs:subClassOf	"queries"
s0.1	"further query"	rdfs:subClassOf	"query"
s0.1	"equivalent queries"	rdfs:member	"equivalent"
s0.1	"conjunctive queries"	rdfs:subClassOf	"queries"
s0.1	"further query features"	rdfs:subClassOf	"features"
s0.1	"query features"	rdfs:member	"query"
s0.1	"conjunctive queries"	rdfs:member	"conjunctive"
s0.1	"further query features"	rdfs:subClassOf	"query features"
s0.1	"where adding"	rdfs:subClassOf	"adding"
s0.1	"two conjunctive queries"	rdfs:subClassOf	"conjunctive queries"
s0.1	"equivalent queries deciding"	rdfs:member	"equivalent queries"
s0.1	"equivalent queries deciding"	rdfs:member	"deciding"
s0	"expressive query languages such as sparql complicated by the difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"
s0	"expressive query languages such as sparql complicated by the difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:subject	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is NPcomplete where adding further query features makes the problem undecidable"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"problem"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"conjunctive queries"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"further query features"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"npcomplete"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"difficulty"
s0	"difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdfs:member	"equivalent queries"
s0	"query features"	rdfs:subClassOf	"features"
s0	"further query"	rdfs:member	"further"
s0	"further query features"	rdfs:member	"further query"
s0	"equivalent queries"	rdfs:subClassOf	"queries"
s0	"further query"	rdfs:subClassOf	"query"
s0	"equivalent queries"	rdfs:member	"equivalent"
s0	"conjunctive queries"	rdfs:subClassOf	"queries"
s0	"further query features"	rdfs:subClassOf	"features"
s0	"query features"	rdfs:member	"query"
s0	"conjunctive queries"	rdfs:member	"conjunctive"
s0	"further query features"	rdfs:subClassOf	"query features"
s0	"where adding"	rdfs:subClassOf	"adding"
s0	"two conjunctive queries"	rdfs:subClassOf	"conjunctive queries"
s0	"equivalent queries deciding"	rdfs:member	"equivalent queries"
s0	"equivalent queries deciding"	rdfs:member	"deciding"
s0	"expressive query languages such as sparql complicated by the difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:predicate	"complicate"
s0	"expressive query languages such as sparql complicated by the difficulty of detecting equivalent queries deciding if two conjunctive queries are equivalent is npcomplete where adding further query features makes the problem undecidable"	rdf:object	"expressive query languages such as SPARQL"
s0	"expressive query languages such as sparql"	rdfs:member	"expressive query languages"
s0	"expressive query languages such as sparql"	rdfs:member	"sparql"
s0	"expressive query languages"	rdfs:subClassOf	"languages"
s0	"query languages"	rdfs:subClassOf	"languages"
s0	"expressive query"	rdfs:subClassOf	"query"
s0	"query languages"	rdfs:member	"query"
s0	"expressive query languages"	rdfs:member	"expressive query"
s0	"expressive query"	rdfs:member	"expressive"
s0	"expressive query languages"	rdfs:subClassOf	"query languages"
s0	"expressive query languages such_as sparql"	rdfs:member	"expressive query languages"
s0	"expressive query languages such_as sparql"	rdfs:member	"sparql"
